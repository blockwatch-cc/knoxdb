// Copyright (c) 2025 Blockwatch Data Inc.
// Code automatically generated - DO NOT EDIT.
// Any manual changes will be lost.

package {{.Package}}

{{- $bitsRange := bitsFuncRange .Bits}}


func bitpack{{$.Bits}}[T uint{{$.Bits}} | int{{$.Bits}}](minv T, in []T, out []uint{{$.Bits}}, log2 int) {
	switch log2 {
		{{- range $bitsize, $value := $bitsRange}}
			case {{$bitsize}}:
				bp{{$.Bits}}_{{$bitsize}}((*[{{$.Bits}}]T)(in), (*[{{$bitsize}}]uint{{$.Bits}})(out), minv)
		{{- end }}
	}

}

{{- range $bitsize, $value := $bitsRange}}        
func bp{{$.Bits}}_{{$bitsize}}[T uint{{$.Bits}} | int{{$.Bits}}](in *[{{$.Bits}}]T, out *[{{$bitsize}}]uint{{$.Bits}}, minv T) {
	{{- $inputIdx := 0 }}
	{{- $offset  := 0 }}
	{{- $offsetShifter := 0 }}
	{{- $shifter := 0 }}
	{{- $shiftRight := false }}
	{{- $bitsizeInnerRange := bitsFuncRange $bitsize}}
	{{- range $vIdx, $vVal := $bitsizeInnerRange }}
		{{- $bitVals := bitRange $.Bits $bitsize $offset}}
		out[{{$vIdx}}] = uint{{$.Bits}}(
			{{- range $bvIdx, $bvVal := $bitVals}}
				{{- if lt $shifter $.Bits }}
					{{- if $shiftRight }}	
						{{- $inputIdx = dec $inputIdx 1 }}
						((in[{{$inputIdx}}] - minv) >> {{$shifter}}) |
						{{- $shifter = dec $bitsize $shifter }}
						{{- $offset = 0 }}
						{{- $inputIdx = inc $inputIdx 1 }}
						{{ $shiftRight = false }}
					{{ else }}
						{{- $nextShift := inc $shifter $bitsize }}
						((in[{{$inputIdx}}] - minv) << {{$shifter}}) {{- if ge $nextShift $.Bits }}) 
						{{ else }} | {{- end}}
						{{- $shifter = $nextShift }}
						{{- $inputIdx = inc $inputIdx 1 }}
						{{- $offset = inc $offset $bitsize }}
					{{- end}}
				{{- end }}
			{{- end}}
		{{- if eq $offset $.Bits }}
			{{- $offset = 0 }}
			{{- $shifter = 0 }}
			{{ $shiftRight = false }}
		{{- else }}
			{{ $shiftRight = true }}
			{{- $shifter = dec $shifter $bitsize }}
		 	{{- $shifter = dec $.Bits $shifter}}
		{{- end }}
	{{- end}}
}

{{- end}}