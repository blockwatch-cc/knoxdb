// Copyright (c) 2020 Blockwatch Data Inc.
// Author: stefan@blockwatch.cc

// perm64 is the VPERMQ input required to permute bytes in each input word
// used by all 64 bit compare algorithms
DATA perm64<>+0x00(SB)/8, $(7)
DATA perm64<>+0x08(SB)/8, $(6)
DATA perm64<>+0x10(SB)/8, $(5)
DATA perm64<>+0x18(SB)/8, $(4)
DATA perm64<>+0x20(SB)/8, $(3)
DATA perm64<>+0x28(SB)/8, $(2)
DATA perm64<>+0x30(SB)/8, $(1)
DATA perm64<>+0x38(SB)/8, $(0)
GLOBL perm64<>(SB), (RODATA+NOPTR), $64

// perm32 is the VPERMD input required to permute bytes in each input word
// used by all 32 bit compare algorithms
DATA perm32<>+0x00(SB)/4, $(7)
DATA perm32<>+0x04(SB)/4, $(6)
DATA perm32<>+0x08(SB)/4, $(5)
DATA perm32<>+0x0C(SB)/4, $(4)
DATA perm32<>+0x10(SB)/4, $(3)
DATA perm32<>+0x14(SB)/4, $(2)
DATA perm32<>+0x18(SB)/4, $(1)
DATA perm32<>+0x1C(SB)/4, $(0)
DATA perm32<>+0x20(SB)/4, $(15)
DATA perm32<>+0x24(SB)/4, $(14)
DATA perm32<>+0x28(SB)/4, $(13)
DATA perm32<>+0x2C(SB)/4, $(12)
DATA perm32<>+0x30(SB)/4, $(11)
DATA perm32<>+0x34(SB)/4, $(10)
DATA perm32<>+0x38(SB)/4, $(9)
DATA perm32<>+0x3C(SB)/4, $(8)
GLOBL perm32<>(SB), (RODATA+NOPTR), $64

// perm16 is the VPERMD input required to permute bytes in each input word
// used by all 32 bit compare algorithms
DATA perm16<>+0x00(SB)/2, $(7)
DATA perm16<>+0x02(SB)/2, $(6)
DATA perm16<>+0x04(SB)/2, $(5)
DATA perm16<>+0x06(SB)/2, $(4)
DATA perm16<>+0x08(SB)/2, $(3)
DATA perm16<>+0x0A(SB)/2, $(2)
DATA perm16<>+0x0C(SB)/2, $(1)
DATA perm16<>+0x0E(SB)/2, $(0)
DATA perm16<>+0x10(SB)/2, $(15)
DATA perm16<>+0x12(SB)/2, $(14)
DATA perm16<>+0x14(SB)/2, $(13)
DATA perm16<>+0x16(SB)/2, $(12)
DATA perm16<>+0x18(SB)/2, $(11)
DATA perm16<>+0x1A(SB)/2, $(10)
DATA perm16<>+0x1C(SB)/2, $(9)
DATA perm16<>+0x1E(SB)/2, $(8)
DATA perm16<>+0x20(SB)/2, $(23)
DATA perm16<>+0x22(SB)/2, $(22)
DATA perm16<>+0x24(SB)/2, $(21)
DATA perm16<>+0x26(SB)/2, $(20)
DATA perm16<>+0x28(SB)/2, $(19)
DATA perm16<>+0x2A(SB)/2, $(18)
DATA perm16<>+0x2C(SB)/2, $(17)
DATA perm16<>+0x2E(SB)/2, $(16)
DATA perm16<>+0x30(SB)/2, $(31)
DATA perm16<>+0x32(SB)/2, $(30)
DATA perm16<>+0x34(SB)/2, $(29)
DATA perm16<>+0x36(SB)/2, $(28)
DATA perm16<>+0x38(SB)/2, $(27)
DATA perm16<>+0x3A(SB)/2, $(26)
DATA perm16<>+0x3C(SB)/2, $(25)
DATA perm16<>+0x3E(SB)/2, $(24)
GLOBL perm16<>(SB), (RODATA+NOPTR), $64

// perm8 is the VPERMD input required to permute bytes in each input word
// used by all 32 bit compare algorithms
DATA perm8<>+0x00(SB)/1, $(7)
DATA perm8<>+0x01(SB)/1, $(6)
DATA perm8<>+0x02(SB)/1, $(5)
DATA perm8<>+0x03(SB)/1, $(4)
DATA perm8<>+0x04(SB)/1, $(3)
DATA perm8<>+0x05(SB)/1, $(2)
DATA perm8<>+0x06(SB)/1, $(1)
DATA perm8<>+0x07(SB)/1, $(0)
DATA perm8<>+0x08(SB)/1, $(15)
DATA perm8<>+0x09(SB)/1, $(14)
DATA perm8<>+0x0A(SB)/1, $(13)
DATA perm8<>+0x0B(SB)/1, $(12)
DATA perm8<>+0x0C(SB)/1, $(11)
DATA perm8<>+0x0D(SB)/1, $(10)
DATA perm8<>+0x0E(SB)/1, $(9)
DATA perm8<>+0x0F(SB)/1, $(8)
DATA perm8<>+0x10(SB)/1, $(23)
DATA perm8<>+0x11(SB)/1, $(22)
DATA perm8<>+0x12(SB)/1, $(21)
DATA perm8<>+0x13(SB)/1, $(20)
DATA perm8<>+0x14(SB)/1, $(19)
DATA perm8<>+0x15(SB)/1, $(18)
DATA perm8<>+0x16(SB)/1, $(17)
DATA perm8<>+0x17(SB)/1, $(16)
DATA perm8<>+0x18(SB)/1, $(31)
DATA perm8<>+0x19(SB)/1, $(30)
DATA perm8<>+0x1A(SB)/1, $(29)
DATA perm8<>+0x1B(SB)/1, $(28)
DATA perm8<>+0x1C(SB)/1, $(27)
DATA perm8<>+0x1D(SB)/1, $(26)
DATA perm8<>+0x1E(SB)/1, $(25)
DATA perm8<>+0x1F(SB)/1, $(24)
DATA perm8<>+0x20(SB)/1, $(39)
DATA perm8<>+0x21(SB)/1, $(38)
DATA perm8<>+0x22(SB)/1, $(37)
DATA perm8<>+0x23(SB)/1, $(36)
DATA perm8<>+0x24(SB)/1, $(35)
DATA perm8<>+0x25(SB)/1, $(34)
DATA perm8<>+0x26(SB)/1, $(33)
DATA perm8<>+0x27(SB)/1, $(32)
DATA perm8<>+0x28(SB)/1, $(47)
DATA perm8<>+0x29(SB)/1, $(46)
DATA perm8<>+0x2A(SB)/1, $(45)
DATA perm8<>+0x2B(SB)/1, $(44)
DATA perm8<>+0x2C(SB)/1, $(43)
DATA perm8<>+0x2D(SB)/1, $(42)
DATA perm8<>+0x2E(SB)/1, $(41)
DATA perm8<>+0x2F(SB)/1, $(40)
DATA perm8<>+0x30(SB)/1, $(55)
DATA perm8<>+0x31(SB)/1, $(54)
DATA perm8<>+0x32(SB)/1, $(53)
DATA perm8<>+0x33(SB)/1, $(52)
DATA perm8<>+0x34(SB)/1, $(51)
DATA perm8<>+0x35(SB)/1, $(50)
DATA perm8<>+0x36(SB)/1, $(49)
DATA perm8<>+0x37(SB)/1, $(48)
DATA perm8<>+0x38(SB)/1, $(63)
DATA perm8<>+0x39(SB)/1, $(62)
DATA perm8<>+0x3A(SB)/1, $(61)
DATA perm8<>+0x3B(SB)/1, $(60)
DATA perm8<>+0x3C(SB)/1, $(59)
DATA perm8<>+0x3D(SB)/1, $(58)
DATA perm8<>+0x3E(SB)/1, $(57)
DATA perm8<>+0x3F(SB)/1, $(56)
GLOBL perm8<>(SB), (RODATA+NOPTR), $64

// counter vector for calculating the bitmask for non fullfilled registers
// used by all compare algorithms
DATA countup64<>+0x00(SB)/8, $(8)
DATA countup64<>+0x08(SB)/8, $(7)
DATA countup64<>+0x10(SB)/8, $(6)
DATA countup64<>+0x18(SB)/8, $(5)
DATA countup64<>+0x20(SB)/8, $(4)
DATA countup64<>+0x28(SB)/8, $(3)
DATA countup64<>+0x30(SB)/8, $(2)
DATA countup64<>+0x38(SB)/8, $(1)
GLOBL countup64<>(SB), (RODATA+NOPTR), $64

// counter vector for calculating the bitmask for non fullfilled registers
// used by all compare algorithms
/*DATA countup32<>+0x00(SB)/4, $(8)
DATA countup32<>+0x04(SB)/4,  $(7)
DATA countup32<>+0x08(SB)/4, $(6)
DATA countup32<>+0x0C(SB)/4, $(5)
DATA countup32<>+0x10(SB)/4, $(4)
DATA countup32<>+0x14(SB)/4, $(3)
DATA countup32<>+0x18(SB)/4, $(2)
DATA countup32<>+0x1C(SB)/4, $(1)
GLOBL countup32<>(SB), (RODATA+NOPTR), $32
*/
